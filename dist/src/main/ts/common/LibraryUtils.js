"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;var _assert = _interopRequireDefault(require("assert"));
var _GenUtils = _interopRequireDefault(require("./GenUtils"));
var _MoneroError = _interopRequireDefault(require("./MoneroError"));
var _ThreadPool = _interopRequireDefault(require("./ThreadPool"));
var _path = _interopRequireDefault(require("path"));

/**
 * Collection of helper utilities for the library.
 */
class LibraryUtils {

  // static variables
  static LOG_LEVEL = 0;





  static WORKER_DIST_PATH_DEFAULT = _GenUtils.default.isBrowser() ? "/monero_web_worker.js" : function () {

    // get worker path in dist (assumes library is running from src or dist)
    let curPath = __dirname;
    if (curPath.indexOf("monero-ts/dist") === -1) curPath = _path.default.join(curPath, "../../../../dist/src/main/js/common");
    return LibraryUtils.prefixWindowsPath(_path.default.join(curPath, "./MoneroWebWorker.js"));
  }();
  static WORKER_DIST_PATH = LibraryUtils.WORKER_DIST_PATH_DEFAULT;

  /**
   * Log a message.
   *
   * @param {number} level - log level of the message
   * @param {string} msg - message to log
   */
  static log(level, msg) {
    (0, _assert.default)(level === parseInt(level, 10) && level >= 0, "Log level must be an integer >= 0");
    if (LibraryUtils.LOG_LEVEL >= level) console.log(msg);
  }

  /**
   * Set the library's log level with 0 being least verbose.
   *
   * @param {number} level - the library's log level
   */
  static async setLogLevel(level) {
    (0, _assert.default)(level === parseInt(level, 10) && level >= 0, "Log level must be an integer >= 0");
    LibraryUtils.LOG_LEVEL = level;
    if (LibraryUtils.WASM_MODULE) LibraryUtils.WASM_MODULE.set_log_level(level);
    if (LibraryUtils.WORKER) await LibraryUtils.invokeWorker(undefined, "setLogLevel", [level]);
  }

  /**
   * Get the library's log level.
   *
   * @return {number} the library's log level
   */
  static getLogLevel() {
    return LibraryUtils.LOG_LEVEL;
  }

  /**
   * Get the total memory used by WebAssembly.
   * 
   * @return {Promise<number>} the total memory used by WebAssembly
   */
  static async getWasmMemoryUsed() {
    let total = 0;
    if (LibraryUtils.WORKER) total += await LibraryUtils.invokeWorker(undefined, "getWasmMemoryUsed", []);
    if (LibraryUtils.getWasmModule() && LibraryUtils.getWasmModule().HEAP8) total += LibraryUtils.getWasmModule().HEAP8.length;
    return total;
  }

  /**
   * Get the WebAssembly module in the current context (nodejs, browser main thread or worker).
   */
  static getWasmModule() {
    return LibraryUtils.WASM_MODULE;
  }

  /**
   * Load the WebAssembly keys module with caching.
   */
  static async loadKeysModule() {

    // use cache if suitable, full module supersedes keys module because it is superset
    if (LibraryUtils.WASM_MODULE) return LibraryUtils.WASM_MODULE;

    // load module
    delete LibraryUtils.WASM_MODULE;
    LibraryUtils.WASM_MODULE = require("../../../../dist/monero_wallet_keys")();
    return new Promise(function (resolve, reject) {
      LibraryUtils.WASM_MODULE.then((module) => {
        LibraryUtils.WASM_MODULE = module;
        delete LibraryUtils.WASM_MODULE.then;
        LibraryUtils.initWasmModule(LibraryUtils.WASM_MODULE);
        resolve(LibraryUtils.WASM_MODULE);
      });
    });
  }

  /**
   * Load the WebAssembly full module with caching.
   * 
   * The full module is a superset of the keys module and overrides it.
   * 
   * TODO: this is separate static function from loadKeysModule() because webpack cannot bundle worker using runtime param for conditional import
   */
  static async loadFullModule() {

    // use cache if suitable, full module supersedes keys module because it is superset
    if (LibraryUtils.WASM_MODULE && LibraryUtils.FULL_LOADED) return LibraryUtils.WASM_MODULE;

    // load module
    delete LibraryUtils.WASM_MODULE;
    LibraryUtils.WASM_MODULE = require("../../../../dist/monero_wallet_full")();
    return new Promise(function (resolve, reject) {
      LibraryUtils.WASM_MODULE.then((module) => {
        LibraryUtils.WASM_MODULE = module;
        delete LibraryUtils.WASM_MODULE.then;
        LibraryUtils.FULL_LOADED = true;
        LibraryUtils.initWasmModule(LibraryUtils.WASM_MODULE);
        resolve(LibraryUtils.WASM_MODULE);
      });
    });
  }

  /**
   * Register a function by id which informs if unauthorized requests (e.g.
   * self-signed certificates) should be rejected.
   * 
   * @param {string} fnId - unique identifier for the function
   * @param {function} fn - function to inform if unauthorized requests should be rejected
   */
  static setRejectUnauthorizedFn(fnId, fn) {
    if (!LibraryUtils.REJECT_UNAUTHORIZED_FNS) LibraryUtils.REJECT_UNAUTHORIZED_FNS = [];
    if (fn === undefined) delete LibraryUtils.REJECT_UNAUTHORIZED_FNS[fnId];else
    LibraryUtils.REJECT_UNAUTHORIZED_FNS[fnId] = fn;
  }

  /**
   * Indicate if unauthorized requests should be rejected.
   * 
   * @param {string} fnId - uniquely identifies the function
   */
  static isRejectUnauthorized(fnId) {
    if (!LibraryUtils.REJECT_UNAUTHORIZED_FNS[fnId]) throw new Error("No function registered with id " + fnId + " to inform if unauthorized reqs should be rejected");
    return LibraryUtils.REJECT_UNAUTHORIZED_FNS[fnId]();
  }

  /**
   * Set the path to load the worker. Defaults to "/monero_web_worker.js" in the browser
   * and "./MoneroWebWorker.js" in node.
   * 
   * @param {string} workerDistPath - path to load the worker
   */
  static setWorkerDistPath(workerDistPath) {
    let path = LibraryUtils.prefixWindowsPath(workerDistPath ? workerDistPath : LibraryUtils.WORKER_DIST_PATH_DEFAULT);
    if (path !== LibraryUtils.WORKER_DIST_PATH) delete LibraryUtils.WORKER;
    LibraryUtils.WORKER_DIST_PATH = path;
  }

  /**
   * Get a singleton instance of a worker to share.
   * 
   * @return {Worker} a worker to share among wallet instances
   */
  static async getWorker() {

    // one time initialization
    if (!LibraryUtils.WORKER) {
      if (_GenUtils.default.isBrowser()) {
        LibraryUtils.WORKER = new Worker(LibraryUtils.WORKER_DIST_PATH);
      } else {
        const Worker = require("web-worker"); // import web worker if nodejs
        LibraryUtils.WORKER = new Worker(LibraryUtils.WORKER_DIST_PATH);
      }
      LibraryUtils.WORKER_OBJECTS = {}; // store per object running in the worker

      // receive worker errors
      LibraryUtils.WORKER.onerror = function (err) {
        console.error("Error posting message to Monero web worker; is it built and copied to the app's build directory (e.g. in the root)?");
        console.log(err);
      };

      // receive worker messages
      LibraryUtils.WORKER.onmessage = function (e) {

        // lookup object id, callback function, and this arg
        let thisArg = undefined;
        let callbackFn = LibraryUtils.WORKER_OBJECTS[e.data[0]].callbacks[e.data[1]]; // look up by object id then by function name
        if (callbackFn === undefined) throw new Error("No worker callback function defined for key '" + e.data[1] + "'");
        if (callbackFn instanceof Array) {// this arg may be stored with callback function
          thisArg = callbackFn[1];
          callbackFn = callbackFn[0];
        }

        // invoke callback function with this arg and arguments
        callbackFn.apply(thisArg, e.data.slice(2));
      };
    }
    return LibraryUtils.WORKER;
  }

  static addWorkerCallback(objectId, callbackId, callbackArgs) {
    LibraryUtils.WORKER_OBJECTS[objectId].callbacks[callbackId] = callbackArgs;
  }

  static removeWorkerCallback(objectId, callbackId) {
    delete LibraryUtils.WORKER_OBJECTS[objectId].callbacks[callbackId];
  }

  static removeWorkerObject(objectId) {
    delete LibraryUtils.WORKER_OBJECTS[objectId];
  }

  /**
   * Terminate monero-ts's singleton worker.
   */
  static async terminateWorker() {
    if (LibraryUtils.WORKER) {
      LibraryUtils.WORKER.terminate();
      delete LibraryUtils.WORKER;
      LibraryUtils.WORKER = undefined;
    }
  }

  /**
   * Invoke a worker function and get the result with error handling.
   * 
   * @param {string} objectId identifies the worker object to invoke (default random id)
   * @param {string} fnName is the name of the function to invoke
   * @param {any[]} [args] are function arguments to invoke with
   * @return {any} resolves with response payload from the worker or an error
   */
  static async invokeWorker(objectId, fnName, args) {
    (0, _assert.default)(fnName.length >= 2);
    let worker = await LibraryUtils.getWorker();
    let randomObject = objectId === undefined;
    if (randomObject) objectId = _GenUtils.default.getUUID();
    if (!LibraryUtils.WORKER_OBJECTS[objectId]) LibraryUtils.WORKER_OBJECTS[objectId] = { callbacks: {} };
    let callbackId = _GenUtils.default.getUUID();
    try {
      return await new Promise((resolve, reject) => {
        LibraryUtils.WORKER_OBJECTS[objectId].callbacks[callbackId] = (resp) => {// TODO: this defines function once per callback
          delete LibraryUtils.WORKER_OBJECTS[objectId].callbacks[callbackId];
          if (randomObject) delete LibraryUtils.WORKER_OBJECTS[objectId];
          resp ? resp.error ? reject(new Error(JSON.stringify(resp.error))) : resolve(resp.result) : resolve(undefined);
        };
        worker.postMessage([objectId, fnName, callbackId].concat(args === undefined ? [] : _GenUtils.default.listify(args)));
      });
    } catch (e) {
      throw LibraryUtils.deserializeError(JSON.parse(e.message));
    }
  }

  static serializeError(err) {
    const serializedErr = { name: err.name, message: err.message, stack: err.stack };
    if (err instanceof _MoneroError.default) serializedErr.type = "MoneroError";
    return serializedErr;
  }

  static deserializeError(serializedErr) {
    const err = serializedErr.type === "MoneroError" ? new _MoneroError.default(serializedErr.message) : new Error(serializedErr.message);
    err.name = serializedErr.name;
    err.stack = err.stack + "\nWorker error: " + serializedErr.stack;
    return err;
  }

  // ------------------------------ PRIVATE HELPERS ---------------------------

  static initWasmModule(wasmModule) {
    wasmModule.taskQueue = new _ThreadPool.default(1);
    wasmModule.queueTask = async function (asyncFn) {return wasmModule.taskQueue.submit(asyncFn);};
  }

  static prefixWindowsPath(path) {
    if (/^[A-Z]:/.test(path) && path.indexOf("file://") == -1) path = "file://" + path; // prepend e.g. C: paths with file://
    return path;
  }
}exports.default = LibraryUtils;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfYXNzZXJ0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfR2VuVXRpbHMiLCJfTW9uZXJvRXJyb3IiLCJfVGhyZWFkUG9vbCIsIl9wYXRoIiwiTGlicmFyeVV0aWxzIiwiTE9HX0xFVkVMIiwiV09SS0VSX0RJU1RfUEFUSF9ERUZBVUxUIiwiR2VuVXRpbHMiLCJpc0Jyb3dzZXIiLCJjdXJQYXRoIiwiX19kaXJuYW1lIiwiaW5kZXhPZiIsInBhdGgiLCJqb2luIiwicHJlZml4V2luZG93c1BhdGgiLCJXT1JLRVJfRElTVF9QQVRIIiwibG9nIiwibGV2ZWwiLCJtc2ciLCJhc3NlcnQiLCJwYXJzZUludCIsImNvbnNvbGUiLCJzZXRMb2dMZXZlbCIsIldBU01fTU9EVUxFIiwic2V0X2xvZ19sZXZlbCIsIldPUktFUiIsImludm9rZVdvcmtlciIsInVuZGVmaW5lZCIsImdldExvZ0xldmVsIiwiZ2V0V2FzbU1lbW9yeVVzZWQiLCJ0b3RhbCIsImdldFdhc21Nb2R1bGUiLCJIRUFQOCIsImxlbmd0aCIsImxvYWRLZXlzTW9kdWxlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJ0aGVuIiwibW9kdWxlIiwiaW5pdFdhc21Nb2R1bGUiLCJsb2FkRnVsbE1vZHVsZSIsIkZVTExfTE9BREVEIiwic2V0UmVqZWN0VW5hdXRob3JpemVkRm4iLCJmbklkIiwiZm4iLCJSRUpFQ1RfVU5BVVRIT1JJWkVEX0ZOUyIsImlzUmVqZWN0VW5hdXRob3JpemVkIiwiRXJyb3IiLCJzZXRXb3JrZXJEaXN0UGF0aCIsIndvcmtlckRpc3RQYXRoIiwiZ2V0V29ya2VyIiwiV29ya2VyIiwiV09SS0VSX09CSkVDVFMiLCJvbmVycm9yIiwiZXJyIiwiZXJyb3IiLCJvbm1lc3NhZ2UiLCJlIiwidGhpc0FyZyIsImNhbGxiYWNrRm4iLCJkYXRhIiwiY2FsbGJhY2tzIiwiQXJyYXkiLCJhcHBseSIsInNsaWNlIiwiYWRkV29ya2VyQ2FsbGJhY2siLCJvYmplY3RJZCIsImNhbGxiYWNrSWQiLCJjYWxsYmFja0FyZ3MiLCJyZW1vdmVXb3JrZXJDYWxsYmFjayIsInJlbW92ZVdvcmtlck9iamVjdCIsInRlcm1pbmF0ZVdvcmtlciIsInRlcm1pbmF0ZSIsImZuTmFtZSIsImFyZ3MiLCJ3b3JrZXIiLCJyYW5kb21PYmplY3QiLCJnZXRVVUlEIiwicmVzcCIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXN1bHQiLCJwb3N0TWVzc2FnZSIsImNvbmNhdCIsImxpc3RpZnkiLCJkZXNlcmlhbGl6ZUVycm9yIiwicGFyc2UiLCJtZXNzYWdlIiwic2VyaWFsaXplRXJyb3IiLCJzZXJpYWxpemVkRXJyIiwibmFtZSIsInN0YWNrIiwiTW9uZXJvRXJyb3IiLCJ0eXBlIiwid2FzbU1vZHVsZSIsInRhc2tRdWV1ZSIsIlRocmVhZFBvb2wiLCJxdWV1ZVRhc2siLCJhc3luY0ZuIiwic3VibWl0IiwidGVzdCIsImV4cG9ydHMiLCJkZWZhdWx0Il0sInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL21haW4vdHMvY29tbW9uL0xpYnJhcnlVdGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0IGZyb20gXCJhc3NlcnRcIjtcbmltcG9ydCBHZW5VdGlscyBmcm9tIFwiLi9HZW5VdGlsc1wiO1xuaW1wb3J0IE1vbmVyb0Vycm9yIGZyb20gXCIuL01vbmVyb0Vycm9yXCI7XG5pbXBvcnQgVGhyZWFkUG9vbCBmcm9tIFwiLi9UaHJlYWRQb29sXCI7XG5pbXBvcnQgcGF0aCBmcm9tIFwicGF0aFwiO1xuXG4vKipcbiAqIENvbGxlY3Rpb24gb2YgaGVscGVyIHV0aWxpdGllcyBmb3IgdGhlIGxpYnJhcnkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpYnJhcnlVdGlscyB7XG5cbiAgLy8gc3RhdGljIHZhcmlhYmxlc1xuICBzdGF0aWMgTE9HX0xFVkVMID0gMDtcbiAgc3RhdGljIFdBU01fTU9EVUxFOiBhbnk7XG4gIHN0YXRpYyBXT1JLRVI6IGFueTtcbiAgc3RhdGljIFdPUktFUl9PQkpFQ1RTOiBhbnk7XG4gIHN0YXRpYyBGVUxMX0xPQURFRDogYW55O1xuICBzdGF0aWMgUkVKRUNUX1VOQVVUSE9SSVpFRF9GTlM6IGFueTtcbiAgc3RhdGljIFdPUktFUl9ESVNUX1BBVEhfREVGQVVMVCA9IEdlblV0aWxzLmlzQnJvd3NlcigpID8gXCIvbW9uZXJvX3dlYl93b3JrZXIuanNcIiA6IGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gZ2V0IHdvcmtlciBwYXRoIGluIGRpc3QgKGFzc3VtZXMgbGlicmFyeSBpcyBydW5uaW5nIGZyb20gc3JjIG9yIGRpc3QpXG4gICAgbGV0IGN1clBhdGggPSBfX2Rpcm5hbWU7XG4gICAgaWYgKGN1clBhdGguaW5kZXhPZihcIm1vbmVyby10cy9kaXN0XCIpID09PSAtMSkgY3VyUGF0aCA9IHBhdGguam9pbihjdXJQYXRoLCBcIi4uLy4uLy4uLy4uL2Rpc3Qvc3JjL21haW4vanMvY29tbW9uXCIpO1xuICAgIHJldHVybiBMaWJyYXJ5VXRpbHMucHJlZml4V2luZG93c1BhdGgocGF0aC5qb2luKGN1clBhdGgsIFwiLi9Nb25lcm9XZWJXb3JrZXIuanNcIikpO1xuICB9KCk7XG4gIHN0YXRpYyBXT1JLRVJfRElTVF9QQVRIID0gTGlicmFyeVV0aWxzLldPUktFUl9ESVNUX1BBVEhfREVGQVVMVDtcbiAgXG4gIC8qKlxuICAgKiBMb2cgYSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGV2ZWwgLSBsb2cgbGV2ZWwgb2YgdGhlIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1zZyAtIG1lc3NhZ2UgdG8gbG9nXG4gICAqL1xuICBzdGF0aWMgbG9nKGxldmVsLCBtc2cpIHtcbiAgICBhc3NlcnQobGV2ZWwgPT09IHBhcnNlSW50KGxldmVsLCAxMCkgJiYgbGV2ZWwgPj0gMCwgXCJMb2cgbGV2ZWwgbXVzdCBiZSBhbiBpbnRlZ2VyID49IDBcIik7XG4gICAgaWYgKExpYnJhcnlVdGlscy5MT0dfTEVWRUwgPj0gbGV2ZWwpIGNvbnNvbGUubG9nKG1zZyk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBTZXQgdGhlIGxpYnJhcnkncyBsb2cgbGV2ZWwgd2l0aCAwIGJlaW5nIGxlYXN0IHZlcmJvc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbCAtIHRoZSBsaWJyYXJ5J3MgbG9nIGxldmVsXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgc2V0TG9nTGV2ZWwobGV2ZWwpIHtcbiAgICBhc3NlcnQobGV2ZWwgPT09IHBhcnNlSW50KGxldmVsLCAxMCkgJiYgbGV2ZWwgPj0gMCwgXCJMb2cgbGV2ZWwgbXVzdCBiZSBhbiBpbnRlZ2VyID49IDBcIik7XG4gICAgTGlicmFyeVV0aWxzLkxPR19MRVZFTCA9IGxldmVsO1xuICAgIGlmIChMaWJyYXJ5VXRpbHMuV0FTTV9NT0RVTEUpIExpYnJhcnlVdGlscy5XQVNNX01PRFVMRS5zZXRfbG9nX2xldmVsKGxldmVsKTtcbiAgICBpZiAoTGlicmFyeVV0aWxzLldPUktFUikgYXdhaXQgTGlicmFyeVV0aWxzLmludm9rZVdvcmtlcih1bmRlZmluZWQsIFwic2V0TG9nTGV2ZWxcIiwgW2xldmVsXSk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpYnJhcnkncyBsb2cgbGV2ZWwuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn0gdGhlIGxpYnJhcnkncyBsb2cgbGV2ZWxcbiAgICovXG4gIHN0YXRpYyBnZXRMb2dMZXZlbCgpOiBudW1iZXIge1xuICAgIHJldHVybiBMaWJyYXJ5VXRpbHMuTE9HX0xFVkVMO1xuICB9XG4gIFxuICAvKipcbiAgICogR2V0IHRoZSB0b3RhbCBtZW1vcnkgdXNlZCBieSBXZWJBc3NlbWJseS5cbiAgICogXG4gICAqIEByZXR1cm4ge1Byb21pc2U8bnVtYmVyPn0gdGhlIHRvdGFsIG1lbW9yeSB1c2VkIGJ5IFdlYkFzc2VtYmx5XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZ2V0V2FzbU1lbW9yeVVzZWQoKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGlmIChMaWJyYXJ5VXRpbHMuV09SS0VSKSB0b3RhbCArPSBhd2FpdCBMaWJyYXJ5VXRpbHMuaW52b2tlV29ya2VyKHVuZGVmaW5lZCwgXCJnZXRXYXNtTWVtb3J5VXNlZFwiLCBbXSkgYXMgbnVtYmVyO1xuICAgIGlmIChMaWJyYXJ5VXRpbHMuZ2V0V2FzbU1vZHVsZSgpICYmIExpYnJhcnlVdGlscy5nZXRXYXNtTW9kdWxlKCkuSEVBUDgpIHRvdGFsICs9IExpYnJhcnlVdGlscy5nZXRXYXNtTW9kdWxlKCkuSEVBUDgubGVuZ3RoO1xuICAgIHJldHVybiB0b3RhbDtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCB0aGUgV2ViQXNzZW1ibHkgbW9kdWxlIGluIHRoZSBjdXJyZW50IGNvbnRleHQgKG5vZGVqcywgYnJvd3NlciBtYWluIHRocmVhZCBvciB3b3JrZXIpLlxuICAgKi9cbiAgc3RhdGljIGdldFdhc21Nb2R1bGUoKSB7XG4gICAgcmV0dXJuIExpYnJhcnlVdGlscy5XQVNNX01PRFVMRTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIExvYWQgdGhlIFdlYkFzc2VtYmx5IGtleXMgbW9kdWxlIHdpdGggY2FjaGluZy5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBsb2FkS2V5c01vZHVsZSgpIHtcbiAgICBcbiAgICAvLyB1c2UgY2FjaGUgaWYgc3VpdGFibGUsIGZ1bGwgbW9kdWxlIHN1cGVyc2VkZXMga2V5cyBtb2R1bGUgYmVjYXVzZSBpdCBpcyBzdXBlcnNldFxuICAgIGlmIChMaWJyYXJ5VXRpbHMuV0FTTV9NT0RVTEUpIHJldHVybiBMaWJyYXJ5VXRpbHMuV0FTTV9NT0RVTEU7XG4gICAgXG4gICAgLy8gbG9hZCBtb2R1bGVcbiAgICBkZWxldGUgTGlicmFyeVV0aWxzLldBU01fTU9EVUxFO1xuICAgIExpYnJhcnlVdGlscy5XQVNNX01PRFVMRSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9kaXN0L21vbmVyb193YWxsZXRfa2V5c1wiKSgpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIExpYnJhcnlVdGlscy5XQVNNX01PRFVMRS50aGVuKG1vZHVsZSA9PiB7XG4gICAgICAgIExpYnJhcnlVdGlscy5XQVNNX01PRFVMRSA9IG1vZHVsZVxuICAgICAgICBkZWxldGUgTGlicmFyeVV0aWxzLldBU01fTU9EVUxFLnRoZW47XG4gICAgICAgIExpYnJhcnlVdGlscy5pbml0V2FzbU1vZHVsZShMaWJyYXJ5VXRpbHMuV0FTTV9NT0RVTEUpO1xuICAgICAgICByZXNvbHZlKExpYnJhcnlVdGlscy5XQVNNX01PRFVMRSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIExvYWQgdGhlIFdlYkFzc2VtYmx5IGZ1bGwgbW9kdWxlIHdpdGggY2FjaGluZy5cbiAgICogXG4gICAqIFRoZSBmdWxsIG1vZHVsZSBpcyBhIHN1cGVyc2V0IG9mIHRoZSBrZXlzIG1vZHVsZSBhbmQgb3ZlcnJpZGVzIGl0LlxuICAgKiBcbiAgICogVE9ETzogdGhpcyBpcyBzZXBhcmF0ZSBzdGF0aWMgZnVuY3Rpb24gZnJvbSBsb2FkS2V5c01vZHVsZSgpIGJlY2F1c2Ugd2VicGFjayBjYW5ub3QgYnVuZGxlIHdvcmtlciB1c2luZyBydW50aW1lIHBhcmFtIGZvciBjb25kaXRpb25hbCBpbXBvcnRcbiAgICovXG4gIHN0YXRpYyBhc3luYyBsb2FkRnVsbE1vZHVsZSgpIHtcbiAgICBcbiAgICAvLyB1c2UgY2FjaGUgaWYgc3VpdGFibGUsIGZ1bGwgbW9kdWxlIHN1cGVyc2VkZXMga2V5cyBtb2R1bGUgYmVjYXVzZSBpdCBpcyBzdXBlcnNldFxuICAgIGlmIChMaWJyYXJ5VXRpbHMuV0FTTV9NT0RVTEUgJiYgTGlicmFyeVV0aWxzLkZVTExfTE9BREVEKSByZXR1cm4gTGlicmFyeVV0aWxzLldBU01fTU9EVUxFO1xuICAgIFxuICAgIC8vIGxvYWQgbW9kdWxlXG4gICAgZGVsZXRlIExpYnJhcnlVdGlscy5XQVNNX01PRFVMRTtcbiAgICBMaWJyYXJ5VXRpbHMuV0FTTV9NT0RVTEUgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZGlzdC9tb25lcm9fd2FsbGV0X2Z1bGxcIikoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBMaWJyYXJ5VXRpbHMuV0FTTV9NT0RVTEUudGhlbihtb2R1bGUgPT4ge1xuICAgICAgICBMaWJyYXJ5VXRpbHMuV0FTTV9NT0RVTEUgPSBtb2R1bGU7XG4gICAgICAgIGRlbGV0ZSBMaWJyYXJ5VXRpbHMuV0FTTV9NT0RVTEUudGhlbjtcbiAgICAgICAgTGlicmFyeVV0aWxzLkZVTExfTE9BREVEID0gdHJ1ZTtcbiAgICAgICAgTGlicmFyeVV0aWxzLmluaXRXYXNtTW9kdWxlKExpYnJhcnlVdGlscy5XQVNNX01PRFVMRSk7XG4gICAgICAgIHJlc29sdmUoTGlicmFyeVV0aWxzLldBU01fTU9EVUxFKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIFxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBmdW5jdGlvbiBieSBpZCB3aGljaCBpbmZvcm1zIGlmIHVuYXV0aG9yaXplZCByZXF1ZXN0cyAoZS5nLlxuICAgKiBzZWxmLXNpZ25lZCBjZXJ0aWZpY2F0ZXMpIHNob3VsZCBiZSByZWplY3RlZC5cbiAgICogXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbklkIC0gdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBmdW5jdGlvblxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiAtIGZ1bmN0aW9uIHRvIGluZm9ybSBpZiB1bmF1dGhvcml6ZWQgcmVxdWVzdHMgc2hvdWxkIGJlIHJlamVjdGVkXG4gICAqL1xuICBzdGF0aWMgc2V0UmVqZWN0VW5hdXRob3JpemVkRm4oZm5JZCwgZm4pIHtcbiAgICBpZiAoIUxpYnJhcnlVdGlscy5SRUpFQ1RfVU5BVVRIT1JJWkVEX0ZOUykgTGlicmFyeVV0aWxzLlJFSkVDVF9VTkFVVEhPUklaRURfRk5TID0gW107XG4gICAgaWYgKGZuID09PSB1bmRlZmluZWQpIGRlbGV0ZSBMaWJyYXJ5VXRpbHMuUkVKRUNUX1VOQVVUSE9SSVpFRF9GTlNbZm5JZF07XG4gICAgZWxzZSBMaWJyYXJ5VXRpbHMuUkVKRUNUX1VOQVVUSE9SSVpFRF9GTlNbZm5JZF0gPSBmbjtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEluZGljYXRlIGlmIHVuYXV0aG9yaXplZCByZXF1ZXN0cyBzaG91bGQgYmUgcmVqZWN0ZWQuXG4gICAqIFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm5JZCAtIHVuaXF1ZWx5IGlkZW50aWZpZXMgdGhlIGZ1bmN0aW9uXG4gICAqL1xuICBzdGF0aWMgaXNSZWplY3RVbmF1dGhvcml6ZWQoZm5JZCkge1xuICAgIGlmICghTGlicmFyeVV0aWxzLlJFSkVDVF9VTkFVVEhPUklaRURfRk5TW2ZuSWRdKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBmdW5jdGlvbiByZWdpc3RlcmVkIHdpdGggaWQgXCIgKyBmbklkICsgXCIgdG8gaW5mb3JtIGlmIHVuYXV0aG9yaXplZCByZXFzIHNob3VsZCBiZSByZWplY3RlZFwiKTtcbiAgICByZXR1cm4gTGlicmFyeVV0aWxzLlJFSkVDVF9VTkFVVEhPUklaRURfRk5TW2ZuSWRdKCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBTZXQgdGhlIHBhdGggdG8gbG9hZCB0aGUgd29ya2VyLiBEZWZhdWx0cyB0byBcIi9tb25lcm9fd2ViX3dvcmtlci5qc1wiIGluIHRoZSBicm93c2VyXG4gICAqIGFuZCBcIi4vTW9uZXJvV2ViV29ya2VyLmpzXCIgaW4gbm9kZS5cbiAgICogXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB3b3JrZXJEaXN0UGF0aCAtIHBhdGggdG8gbG9hZCB0aGUgd29ya2VyXG4gICAqL1xuICBzdGF0aWMgc2V0V29ya2VyRGlzdFBhdGgod29ya2VyRGlzdFBhdGgpIHtcbiAgICBsZXQgcGF0aCA9IExpYnJhcnlVdGlscy5wcmVmaXhXaW5kb3dzUGF0aCh3b3JrZXJEaXN0UGF0aCA/IHdvcmtlckRpc3RQYXRoIDogTGlicmFyeVV0aWxzLldPUktFUl9ESVNUX1BBVEhfREVGQVVMVCk7XG4gICAgaWYgKHBhdGggIT09IExpYnJhcnlVdGlscy5XT1JLRVJfRElTVF9QQVRIKSBkZWxldGUgTGlicmFyeVV0aWxzLldPUktFUjtcbiAgICBMaWJyYXJ5VXRpbHMuV09SS0VSX0RJU1RfUEFUSCA9IHBhdGg7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIGEgd29ya2VyIHRvIHNoYXJlLlxuICAgKiBcbiAgICogQHJldHVybiB7V29ya2VyfSBhIHdvcmtlciB0byBzaGFyZSBhbW9uZyB3YWxsZXQgaW5zdGFuY2VzXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZ2V0V29ya2VyKCkge1xuICAgIFxuICAgIC8vIG9uZSB0aW1lIGluaXRpYWxpemF0aW9uXG4gICAgaWYgKCFMaWJyYXJ5VXRpbHMuV09SS0VSKSB7XG4gICAgICBpZiAoR2VuVXRpbHMuaXNCcm93c2VyKCkpIHtcbiAgICAgICAgTGlicmFyeVV0aWxzLldPUktFUiA9IG5ldyBXb3JrZXIoTGlicmFyeVV0aWxzLldPUktFUl9ESVNUX1BBVEgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgV29ya2VyID0gcmVxdWlyZShcIndlYi13b3JrZXJcIik7IC8vIGltcG9ydCB3ZWIgd29ya2VyIGlmIG5vZGVqc1xuICAgICAgICBMaWJyYXJ5VXRpbHMuV09SS0VSID0gbmV3IFdvcmtlcihMaWJyYXJ5VXRpbHMuV09SS0VSX0RJU1RfUEFUSCk7XG4gICAgICB9XG4gICAgICBMaWJyYXJ5VXRpbHMuV09SS0VSX09CSkVDVFMgPSB7fTsgIC8vIHN0b3JlIHBlciBvYmplY3QgcnVubmluZyBpbiB0aGUgd29ya2VyXG4gICAgICBcbiAgICAgIC8vIHJlY2VpdmUgd29ya2VyIGVycm9yc1xuICAgICAgTGlicmFyeVV0aWxzLldPUktFUi5vbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwb3N0aW5nIG1lc3NhZ2UgdG8gTW9uZXJvIHdlYiB3b3JrZXI7IGlzIGl0IGJ1aWx0IGFuZCBjb3BpZWQgdG8gdGhlIGFwcCdzIGJ1aWxkIGRpcmVjdG9yeSAoZS5nLiBpbiB0aGUgcm9vdCk/XCIpO1xuICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gcmVjZWl2ZSB3b3JrZXIgbWVzc2FnZXNcbiAgICAgIExpYnJhcnlVdGlscy5XT1JLRVIub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBcbiAgICAgICAgLy8gbG9va3VwIG9iamVjdCBpZCwgY2FsbGJhY2sgZnVuY3Rpb24sIGFuZCB0aGlzIGFyZ1xuICAgICAgICBsZXQgdGhpc0FyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGNhbGxiYWNrRm4gPSBMaWJyYXJ5VXRpbHMuV09SS0VSX09CSkVDVFNbZS5kYXRhWzBdXS5jYWxsYmFja3NbZS5kYXRhWzFdXTsgLy8gbG9vayB1cCBieSBvYmplY3QgaWQgdGhlbiBieSBmdW5jdGlvbiBuYW1lXG4gICAgICAgIGlmIChjYWxsYmFja0ZuID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihcIk5vIHdvcmtlciBjYWxsYmFjayBmdW5jdGlvbiBkZWZpbmVkIGZvciBrZXkgJ1wiICsgZS5kYXRhWzFdICsgXCInXCIpO1xuICAgICAgICBpZiAoY2FsbGJhY2tGbiBpbnN0YW5jZW9mIEFycmF5KSB7ICAvLyB0aGlzIGFyZyBtYXkgYmUgc3RvcmVkIHdpdGggY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgICB0aGlzQXJnID0gY2FsbGJhY2tGblsxXTtcbiAgICAgICAgICBjYWxsYmFja0ZuID0gY2FsbGJhY2tGblswXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gaW52b2tlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggdGhpcyBhcmcgYW5kIGFyZ3VtZW50c1xuICAgICAgICBjYWxsYmFja0ZuLmFwcGx5KHRoaXNBcmcsIGUuZGF0YS5zbGljZSgyKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBMaWJyYXJ5VXRpbHMuV09SS0VSO1xuICB9XG5cbiAgc3RhdGljIGFkZFdvcmtlckNhbGxiYWNrKG9iamVjdElkLCBjYWxsYmFja0lkLCBjYWxsYmFja0FyZ3MpIHtcbiAgICBMaWJyYXJ5VXRpbHMuV09SS0VSX09CSkVDVFNbb2JqZWN0SWRdLmNhbGxiYWNrc1tjYWxsYmFja0lkXSA9IGNhbGxiYWNrQXJncztcbiAgfVxuXG4gIHN0YXRpYyByZW1vdmVXb3JrZXJDYWxsYmFjayhvYmplY3RJZCwgY2FsbGJhY2tJZCkge1xuICAgIGRlbGV0ZSBMaWJyYXJ5VXRpbHMuV09SS0VSX09CSkVDVFNbb2JqZWN0SWRdLmNhbGxiYWNrc1tjYWxsYmFja0lkXTtcbiAgfVxuXG4gIHN0YXRpYyByZW1vdmVXb3JrZXJPYmplY3Qob2JqZWN0SWQpIHtcbiAgICBkZWxldGUgTGlicmFyeVV0aWxzLldPUktFUl9PQkpFQ1RTW29iamVjdElkXTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFRlcm1pbmF0ZSBtb25lcm8tdHMncyBzaW5nbGV0b24gd29ya2VyLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHRlcm1pbmF0ZVdvcmtlcigpIHtcbiAgICBpZiAoTGlicmFyeVV0aWxzLldPUktFUikge1xuICAgICAgTGlicmFyeVV0aWxzLldPUktFUi50ZXJtaW5hdGUoKTtcbiAgICAgIGRlbGV0ZSBMaWJyYXJ5VXRpbHMuV09SS0VSO1xuICAgICAgTGlicmFyeVV0aWxzLldPUktFUiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlIGEgd29ya2VyIGZ1bmN0aW9uIGFuZCBnZXQgdGhlIHJlc3VsdCB3aXRoIGVycm9yIGhhbmRsaW5nLlxuICAgKiBcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9iamVjdElkIGlkZW50aWZpZXMgdGhlIHdvcmtlciBvYmplY3QgdG8gaW52b2tlIChkZWZhdWx0IHJhbmRvbSBpZClcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZuTmFtZSBpcyB0aGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gICAqIEBwYXJhbSB7YW55W119IFthcmdzXSBhcmUgZnVuY3Rpb24gYXJndW1lbnRzIHRvIGludm9rZSB3aXRoXG4gICAqIEByZXR1cm4ge2FueX0gcmVzb2x2ZXMgd2l0aCByZXNwb25zZSBwYXlsb2FkIGZyb20gdGhlIHdvcmtlciBvciBhbiBlcnJvclxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGludm9rZVdvcmtlcihvYmplY3RJZCwgZm5OYW1lLCBhcmdzKSB7XG4gICAgYXNzZXJ0KGZuTmFtZS5sZW5ndGggPj0gMik7XG4gICAgbGV0IHdvcmtlciA9IGF3YWl0IExpYnJhcnlVdGlscy5nZXRXb3JrZXIoKTtcbiAgICBsZXQgcmFuZG9tT2JqZWN0ID0gb2JqZWN0SWQgPT09IHVuZGVmaW5lZDtcbiAgICBpZiAocmFuZG9tT2JqZWN0KSBvYmplY3RJZCA9IEdlblV0aWxzLmdldFVVSUQoKTtcbiAgICBpZiAoIUxpYnJhcnlVdGlscy5XT1JLRVJfT0JKRUNUU1tvYmplY3RJZF0pIExpYnJhcnlVdGlscy5XT1JLRVJfT0JKRUNUU1tvYmplY3RJZF0gPSB7Y2FsbGJhY2tzOiB7fX07XG4gICAgbGV0IGNhbGxiYWNrSWQgPSBHZW5VdGlscy5nZXRVVUlEKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIExpYnJhcnlVdGlscy5XT1JLRVJfT0JKRUNUU1tvYmplY3RJZF0uY2FsbGJhY2tzW2NhbGxiYWNrSWRdID0gKHJlc3ApID0+IHsgIC8vIFRPRE86IHRoaXMgZGVmaW5lcyBmdW5jdGlvbiBvbmNlIHBlciBjYWxsYmFja1xuICAgICAgICAgIGRlbGV0ZSBMaWJyYXJ5VXRpbHMuV09SS0VSX09CSkVDVFNbb2JqZWN0SWRdLmNhbGxiYWNrc1tjYWxsYmFja0lkXTtcbiAgICAgICAgICBpZiAocmFuZG9tT2JqZWN0KSBkZWxldGUgTGlicmFyeVV0aWxzLldPUktFUl9PQkpFQ1RTW29iamVjdElkXTtcbiAgICAgICAgICByZXNwID8gKHJlc3AuZXJyb3IgPyByZWplY3QobmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KHJlc3AuZXJyb3IpKSkgOiByZXNvbHZlKHJlc3AucmVzdWx0KSkgOiByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgIH07XG4gICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZShbb2JqZWN0SWQsIGZuTmFtZSwgY2FsbGJhY2tJZF0uY29uY2F0KGFyZ3MgPT09IHVuZGVmaW5lZCA/IFtdIDogR2VuVXRpbHMubGlzdGlmeShhcmdzKSkpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICB0aHJvdyBMaWJyYXJ5VXRpbHMuZGVzZXJpYWxpemVFcnJvcihKU09OLnBhcnNlKGUubWVzc2FnZSkpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBzZXJpYWxpemVFcnJvcihlcnIpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkRXJyOiBhbnkgPSB7IG5hbWU6IGVyci5uYW1lLCBtZXNzYWdlOiBlcnIubWVzc2FnZSwgc3RhY2s6IGVyci5zdGFjayB9O1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBNb25lcm9FcnJvcikgc2VyaWFsaXplZEVyci50eXBlID0gXCJNb25lcm9FcnJvclwiO1xuICAgIHJldHVybiBzZXJpYWxpemVkRXJyO1xuICB9XG5cbiAgcHJvdGVjdGVkIHN0YXRpYyBkZXNlcmlhbGl6ZUVycm9yKHNlcmlhbGl6ZWRFcnIpIHtcbiAgICBjb25zdCBlcnIgPSBzZXJpYWxpemVkRXJyLnR5cGUgPT09IFwiTW9uZXJvRXJyb3JcIiA/IG5ldyBNb25lcm9FcnJvcihzZXJpYWxpemVkRXJyLm1lc3NhZ2UpIDogbmV3IEVycm9yKHNlcmlhbGl6ZWRFcnIubWVzc2FnZSk7XG4gICAgZXJyLm5hbWUgPSBzZXJpYWxpemVkRXJyLm5hbWU7XG4gICAgZXJyLnN0YWNrID0gZXJyLnN0YWNrICsgXCJcXG5Xb3JrZXIgZXJyb3I6IFwiICsgc2VyaWFsaXplZEVyci5zdGFjaztcbiAgICByZXR1cm4gZXJyO1xuICB9XG4gIFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUFJJVkFURSBIRUxQRVJTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBcbiAgcHJvdGVjdGVkIHN0YXRpYyBpbml0V2FzbU1vZHVsZSh3YXNtTW9kdWxlKSB7XG4gICAgd2FzbU1vZHVsZS50YXNrUXVldWUgPSBuZXcgVGhyZWFkUG9vbCgxKTtcbiAgICB3YXNtTW9kdWxlLnF1ZXVlVGFzayA9IGFzeW5jIGZ1bmN0aW9uKGFzeW5jRm4pIHsgcmV0dXJuIHdhc21Nb2R1bGUudGFza1F1ZXVlLnN1Ym1pdChhc3luY0ZuKTsgfVxuICB9XG4gIFxuICBwcm90ZWN0ZWQgc3RhdGljIHByZWZpeFdpbmRvd3NQYXRoKHBhdGgpIHtcbiAgICBpZiAoL15bQS1aXTovLnRlc3QocGF0aCkgJiYgcGF0aC5pbmRleE9mKFwiZmlsZTovL1wiKSA9PSAtMSkgcGF0aCA9IFwiZmlsZTovL1wiICsgcGF0aDsgLy8gcHJlcGVuZCBlLmcuIEM6IHBhdGhzIHdpdGggZmlsZTovL1xuICAgIHJldHVybiBwYXRoO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiJ5TEFBQSxJQUFBQSxPQUFBLEdBQUFDLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBQyxTQUFBLEdBQUFGLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBRSxZQUFBLEdBQUFILHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBRyxXQUFBLEdBQUFKLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBSSxLQUFBLEdBQUFMLHNCQUFBLENBQUFDLE9BQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ2UsTUFBTUssWUFBWSxDQUFDOztFQUVoQztFQUNBLE9BQU9DLFNBQVMsR0FBRyxDQUFDOzs7Ozs7RUFNcEIs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